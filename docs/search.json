[
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/gaussian_processes/gp.html",
    "href": "posts/gaussian_processes/gp.html",
    "title": "Introduction to Gaussian Processes",
    "section": "",
    "text": "This article introduces Gaussian Processes (GPs), discussing their mathematical foundations and practical applications in regression tasks. Python code examples demonstrate their implementation with squared exponential and Matérn kernels, including handling noisy measurements."
  },
  {
    "objectID": "posts/gaussian_processes/gp.html#abstract",
    "href": "posts/gaussian_processes/gp.html#abstract",
    "title": "Introduction to Gaussian Processes",
    "section": "",
    "text": "This article introduces Gaussian Processes (GPs), discussing their mathematical foundations and practical applications in regression tasks. Python code examples demonstrate their implementation with squared exponential and Matérn kernels, including handling noisy measurements."
  },
  {
    "objectID": "posts/gaussian_processes/gp.html#introduction",
    "href": "posts/gaussian_processes/gp.html#introduction",
    "title": "Introduction to Gaussian Processes",
    "section": "Introduction",
    "text": "Introduction\nGaussian Processes (GPs) are a powerful, non-parametric tool for modeling and understanding data. They provide a probabilistic approach to learning in kernel-defined function spaces, making them particularly useful for regression and optimization tasks."
  },
  {
    "objectID": "posts/gaussian_processes/gp.html#gaussian-processes",
    "href": "posts/gaussian_processes/gp.html#gaussian-processes",
    "title": "Introduction to Gaussian Processes",
    "section": "Gaussian Processes",
    "text": "Gaussian Processes\n\nWhat is a Gaussian Process?\nGaussian Processes (GPs) are a non-parametric method for regression and classification tasks. They define a distribution over functions and can provide uncertainty measures for predictions.\n\n\nMathematical Formulation\nA Gaussian Process is completely specified by its mean function \\(m(x)\\) and covariance function \\(k(x, x')\\):\n\\[\nf(x) \\sim GP(m(x), k(x, x'))\n\\]\nwhere:\n\n\\(m(x) = \\mathbb{E}[f(x)]\\)\n\\(k(x, x') = \\mathbb{E}[(f(x) - m(x))(f(x') - m(x'))]\\)\n\nThe mean function is often assumed to be zero for simplicity \\(m(x) = 0\\).\nThe covariance function (kernel) defines the shape and smoothness of the functions sampled from the GP. Common choices for kernels include the squared exponential (RBF) kernel and the Matérn kernel.\n\n\nSquared Exponential Kernel\nThe squared exponential kernel (also known as the RBF kernel) is defined as:\n\\[\nk_{\\text{Exp}}(x, x') = \\sigma^2 \\exp \\left( -\\frac{(x - x')^2}{2l^2} \\right)\n\\]\nwhere \\(\\sigma^2\\) is the variance and \\(l\\) is the length scale.\n#| standalone: true\n#| viewerHeight: 475\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import multivariate_normal\nfrom shiny import App, render, ui\n\n\n# Define the kernel function\ndef exponential_quadratic_kernel(x1, x2, l=1.0, sigma2=1.0):\n    \"\"\"Computes the exponential quadratic kernel (squared exponential kernel).\"\"\"\n    sqdist = np.sum(x1**2, 1).reshape(-1, 1) + np.sum(x2**2, 1) - 2 * np.dot(x1, x2.T)\n    return sigma2 * np.exp(-0.5 / l**2 * sqdist)\n\n# Define the input space\nX = np.linspace(-4, 4, 100).reshape(-1, 1)\n\ndef plot_kernel_and_samples(l, sigma2):\n    # Compute the kernel matrix\n    K = exponential_quadratic_kernel(X, X, l=l, sigma2=sigma2)\n\n    # Create the plot\n    fig, ax = plt.subplots(2, 1, figsize=(18, 6), sharex=True)\n\n    # Plot the kernel\n    ax[0].plot(X, exponential_quadratic_kernel(X, np.zeros((1,1)), l=l, sigma2=sigma2))\n    ax[0].set_title(f\"Squared exponential kernel function\")\n\n    # Sample 5 functions from the Gaussian process defined by the kernel\n    mean = np.zeros(100)\n    cov = K\n    samples = multivariate_normal.rvs(mean, cov, 5)\n\n    # Plot the samples\n    for i in range(5):\n        ax[1].plot(X, samples[i])\n    ax[1].set_title(\"Samples from the GP\")\n    ax[1].set_xlabel(\"x\")\n\n    plt.tight_layout()\n    return fig\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n            ui.input_slider(\"length_scale\", \"Length Scale (l):\", min=0.1, max=5.0, value=1.0, step=0.1),\n            ui.input_slider(\"variance\", \"Variance (σ²):\", min=0.1, max=5.0, value=1.0, step=0.1)\n        ),\n        ui.panel_main(\n            ui.output_plot(\"kernelPlot\")\n        )\n    )\n)\n\ndef server(input, output, session):\n    @output\n    @render.plot\n    def kernelPlot():\n        l = input.length_scale()\n        sigma2 = input.variance()\n        fig = plot_kernel_and_samples(l, sigma2)\n        return fig\n\napp = App(app_ui, server)\n\n\nMatérn kernel\nThe Matérn kernel is defined as:\n\\[\nk_{\\text{Matérn}}(x, x') = \\sigma^2 \\frac{2^{1-\\nu}}{\\Gamma(\\nu)} \\left( \\sqrt{2\\nu} \\frac{|x - x'|}{l} \\right)^{\\nu} K_{\\nu} \\left( \\sqrt{2\\nu} \\frac{|x - x'|}{l} \\right)\n\\]\nwhere \\(\\nu\\) controls the smoothness of the function, \\(l\\) is the length scale, \\(\\sigma^2\\) is the variance, and \\(K_{\\nu}\\) is the modified Bessel function.\n#| standalone: true\n#| viewerHeight: 475\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import multivariate_normal\nfrom shiny import App, render, ui\nfrom scipy.special import kv, gamma\nfrom scipy.spatial.distance import cdist\n\n\n# Define the kernel function\ndef matern_kernel(x1, x2, l=1.0, sigma2=1.0, nu=1.5):\n    \"\"\"Computes the Matérn kernel.\"\"\"\n    D = cdist(x1, x2, 'euclidean')\n    const = (2**(1-nu))/gamma(nu)\n    K = sigma2 * const * (np.sqrt(2*nu)*D/l)**nu * kv(nu, np.sqrt(2*nu)*D/l)\n    # Replace NaN values with 1 for x == x'\n    K[np.isnan(K)] = 1\n    return K\n\n# Define the input space\nX = np.linspace(-4, 4, 100).reshape(-1, 1)\n\ndef plot_kernel_and_samples(l, sigma2, nu):\n    # Compute the kernel matrix\n    K = matern_kernel(X, X, l=l, sigma2=sigma2, nu=nu)\n\n    # Create the plot\n    fig, ax = plt.subplots(2, 1, figsize=(18, 6), sharex=True)\n\n    # Plot the kernel\n    ax[0].plot(X, matern_kernel(X, np.zeros((1,1)), l=l, sigma2=sigma2, nu=nu))\n    ax[0].set_title(f\"Matern kernel function\")\n\n    # Sample 5 functions from the Gaussian process defined by the kernel\n    mean = np.zeros(100)\n    cov = K\n    samples = multivariate_normal.rvs(mean, cov, 5)\n\n    # Plot the samples\n    for i in range(5):\n        ax[1].plot(X, samples[i])\n    ax[1].set_title(\"Samples from the GP\")\n    ax[1].set_xlabel(\"x\")\n\n    plt.tight_layout()\n    return fig\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n            ui.input_slider(\"length_scale\", \"Length Scale (l):\", min=0.1, max=5.0, value=1.0, step=0.1),\n            ui.input_slider(\"variance\", \"Variance (σ²):\", min=0.1, max=5.0, value=1.0, step=0.1),\n            ui.input_slider(\"smoothness_param\", \"Smoothness param (v):\", min=1.5, max=5.0, value=1.5, step=0.5)\n        ),\n        ui.panel_main(\n            ui.output_plot(\"kernelPlot\")\n        )\n    )\n)\n\ndef server(input, output, session):\n    @output\n    @render.plot\n    def kernelPlot():\n        l = input.length_scale()\n        sigma2 = input.variance()\n        nu = input.smoothness_param()\n        fig = plot_kernel_and_samples(l, sigma2, nu)\n        return fig\n\napp = App(app_ui, server)\n\n\nNoisy measurements\nHandling noisy observations in GPs involves adding a noise term to the covariance matrix. The noisy observations are modeled as:\n\\[\ny = f(x) + \\epsilon\n\\]\nwhere \\(\\epsilon \\sim \\mathcal{N}(0, \\sigma_n^2)\\).\n#| standalone: true\n#| viewerHeight: 475\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import multivariate_normal\nfrom shiny import App, render, ui\nfrom scipy.spatial.distance import cdist\nfrom scipy.special import kv, gamma\n\n# Define the kernel functions\ndef exponential_quadratic_kernel(x1, x2, l=1.0, sigma2=1.0):\n    \"\"\"Computes the exponential quadratic kernel (squared exponential kernel).\"\"\"\n    sqdist = np.sum(x1**2, 1).reshape(-1, 1) + np.sum(x2**2, 1) - 2 * np.dot(x1, x2.T)\n    return sigma2 * np.exp(-0.5 / l**2 * sqdist)\n\ndef matern_kernel(x1, x2, l=1.0, sigma2=1.0, nu=1.5):\n    \"\"\"Computes the Matérn kernel.\"\"\"\n    D = cdist(x1, x2, 'euclidean')\n    const = (2**(1-nu))/gamma(nu)\n    K = sigma2 * const * (np.sqrt(2*nu)*D/l)**nu * kv(nu, np.sqrt(2*nu)*D/l)\n    # Replace NaN values with 1 for x == x'\n    K[np.isnan(K)] = 1\n    return K\n\n# Define the input space\nX = np.linspace(-4, 4, 100).reshape(-1, 1)\n\ndef plot_kernels_and_samples(noise_level):\n    # Generate training data with noise\n    X_train = np.array([-3, -2, -1, 1, 3.5]).reshape(-1, 1)\n    y_train = np.sin(X_train) + noise_level * np.random.randn(X_train.shape[0], 1).reshape(-1,1)\n\n    # Compute the kernel matrices for training data\n    K_train_exp = exponential_quadratic_kernel(X_train, X_train) + noise_level**2 * np.eye(len(X_train))\n    K_s_exp = exponential_quadratic_kernel(X_train, X)\n    K_ss_exp = exponential_quadratic_kernel(X, X)\n    \n    K_train_matern = matern_kernel(X_train, X_train) + noise_level**2 * np.eye(len(X_train))\n    K_s_matern = matern_kernel(X_train, X)\n    K_ss_matern = matern_kernel(X, X)\n\n    # Compute the mean and covariance of the posterior distribution for exponential kernel\n    K_train_inv_exp = np.linalg.inv(K_train_exp)\n    mu_s_exp = (K_s_exp.T.dot(K_train_inv_exp).dot(y_train)).reshape(-1)\n    cov_s_exp = K_ss_exp - K_s_exp.T.dot(K_train_inv_exp).dot(K_s_exp)\n\n    # Compute the mean and covariance of the posterior distribution for Matérn kernel\n    K_train_inv_matern = np.linalg.inv(K_train_matern)\n    mu_s_matern = (K_s_matern.T.dot(K_train_inv_matern).dot(y_train)).reshape(-1)\n    cov_s_matern = K_ss_matern - K_s_matern.T.dot(K_train_inv_matern).dot(K_s_matern)\n\n    # Sample 5 functions from the posterior distribution for both kernels\n    samples_exp = multivariate_normal.rvs(mu_s_exp, cov_s_exp, 5)\n    samples_matern = multivariate_normal.rvs(mu_s_matern, cov_s_matern, 5)\n\n    # Create the plot\n    fig, ax = plt.subplots(2, 1, figsize=(18, 6), sharex=True)\n\n    # Plot the training data and GP predictions for exponential kernel\n    ax[0].scatter(X_train, y_train, color='black', zorder=10, label='Noisy observations')\n    ax[0].plot(X, mu_s_exp, color='blue', label='Mean')\n    ax[0].plot(X, np.sin(X), color='black', label='True function')\n    ax[0].fill_between(X.ravel(), mu_s_exp - 1.96 * np.sqrt(np.diag(cov_s_exp)), mu_s_exp + 1.96 * np.sqrt(np.diag(cov_s_exp)), color=\"blue\", alpha=0.2, label='95% confidence interval')\n    # for i in range(5):\n    #     ax[0].plot(X, samples_exp[i], alpha=0.5, linestyle='--')\n    ax[0].set_title(f\"Squared exponential kernel\")\n    # ax[0].legend()\n\n    # Plot the training data and GP predictions for Matérn kernel\n    ax[1].scatter(X_train, y_train, color='black', zorder=10, label='Noisy observations')\n    ax[1].plot(X, mu_s_matern, color=\"blue\", label='Mean')\n    ax[1].plot(X, np.sin(X), color=\"black\", label='True function')\n    ax[1].fill_between(X.ravel(), mu_s_matern - 1.96 * np.sqrt(np.diag(cov_s_matern)), mu_s_matern + 1.96 * np.sqrt(np.diag(cov_s_matern)), color=\"blue\", alpha=0.2, label='95% confidence interval')\n    # for i in range(5):\n    #     ax[1].plot(X, samples_matern[i], alpha=0.5, linestyle='--')\n    ax[1].set_title(f\"Matérn kernel\")\n    # ax[1].legend()\n    ax[1].set_xlabel(\"x\")\n\n    plt.tight_layout()\n    return fig\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n            ui.input_slider(\"noise_level\", \"Noise Level (σ²ₙ):\", min=0.01, max=1.0, value=0.1, step=0.01)\n        ),\n        ui.panel_main(\n            ui.output_plot(\"kernelPlot\")\n        )\n    )\n)\n\ndef server(input, output, session):\n    @output\n    @render.plot\n    def kernelPlot():\n        noise_level = input.noise_level()\n        fig = plot_kernels_and_samples(noise_level)\n        return fig\n\napp = App(app_ui, server)\nAccording to the data, the GP model effectively captures the underlying function and provides uncertainty estimates."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "RuglioBoi",
    "section": "",
    "text": "Introduction to Gaussian Processes\n\n\n\n\n\n\n\n\n\n\n\nJun 25, 2024\n\n\nAndrea Ruglioni\n\n\n\n\n\n\n\n\n\n\n\n\nPost With Code\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nJun 25, 2024\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nJun 22, 2024\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.linspace(0, 2*np.pi)\ny = np.sin(x)\n\nfig, ax = plt.subplots()\nax.plot(x, y)\nax.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1: sine plot\n\n\n\n\n\nFigure 1 is a plot"
  }
]